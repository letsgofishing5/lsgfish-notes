### 数据代理(浅代理)
    将data中的直接属性一个个拿出来 得到名字后 给vm实例对象绑定同名属性
    并且绑定给vm实例对象的属性都是访问描述符 具有get&set方法!
    对应的get方法本质上还是访问的data中的直接属性
    对应的set方法本质上还是修改的data中的直接属性


### 数据劫持(深劫持)
    通过递归将data中的属性一个个拿出来;
    给他们分配dep(闭包);
    将他们重新定义为访问描述符 具有get&set方法!
    以后对data中的属性发起访问或修改走的都是get&set方法!


### 模板解析(深解析)
    将el指定的节点中的内容 剪切到 文档碎片中; 在文档碎片中深度递归解析每一个节点的内容
    和节点属性;如果发现内容满足 {{}} 表达式的匹配则进行解析;如果发现节点的属性满足v-开头
    也进行解析.

    任意一个指令或插值的解析最终都会到compileUtil中调到一个编译器;
    在编译器中都会在执行bind方法;在bind方法中会根据指令不同去updater中
    找不同的更新器!

### 数据响应式
    1. data中的每一个属性都具有一个dep闭包!
    2. 每一个指令在被解析的最后一步都会创建一个watcher;
            这个watcher持有着当前指令对应的更新器(闭包)

    出于使用的需求;dep和watcher之间应该要建立多对多关系!!
    dep和watcher之间的多对多关系是怎么构建的?
         在指令解析的最后一步 调用了new Watcher() 此时开始构建多对多关系
         以 v-html="obj.msg.text"  {{obj.mgs.text2}} 来距离

         v-html="obj.msg.text"被解析完:
           v-html.watcher.depId:{
                0:obj.dep,                  obj.dep.subs:[v-html.watcher]
                1:msg.dep,                  msg.dep.subs:[v-html.watcher]
                2:text.dep                  text.dep.subs:[v-html.watcher]
           }

         {{obj.mgs.text2}} 再被解析完
            v-html.watcher.depIds:{
                0:obj.dep,
                1:msg.dep,
                2:text.dep
            }

            {{}}.watcher.depIds:{
                0:obj.dep,
                1:msg.dep,
                2:text2.dep
            }

            obj.dep.subs:[v-html.watcher,{{}}.watcher]
            msg.dep.subs:[v-html.watcher,{{}}.watcher]
            text.dep.subs:[v-html.watcher]
            text2.dep.subs:[{{}}.watcher]

### 数据双向绑定
    v-model指令  : vue数据双向绑定.png
# 算法

### 链表

1. 单向链表常用解决方案就是：**虚拟头节点**



### 哈希表

当给你一个元素，判断这个元素是否在这个集合里出现过的时候，适合用哈希表解决问题



### 栈与队列

栈适合做相邻元素之间的关联处理



### 二叉树

#### 存储方式

- 链式存储（树）
- 线性存储（数组）

#### 遍历方式

- 深度遍历（递归遍历，迭代遍历）：所有递归方法都可以使用**模拟栈**来迭代实现

  - 前序：中左右

    - ```go
      //递归遍历
      func preorderTraversal(root *TreeNode) []int {
      	if root == nil {
      		return nil
      	}
      	tmp := []int{}
      	tmp = append(tmp, root.Val)
      	tmp = append(tmp, preorderTraversal(root.Left)...)
      	tmp = append(tmp, preorderTraversal(root.Right)...)
      	return tmp
      }
      //迭代遍历
      func preorderTraversal(root *TreeNode) []int {
      	stack := []*TreeNode{}
      	record := []int{}
      	stack = append(stack, root)
      	for len(stack) != 0 {
      		cur := stack[len(stack)-1]
      		stack = stack[:len(stack)-1]
      		if cur != nil {
      			record = append(record, cur.Val)
      			if cur.Right != nil {
      				stack = append(stack, cur.Right)
      			}
      			if cur.Left != nil {
      				stack = append(stack, cur.Left)
      			}
      		}
      	}
      	return record
      }
      ```
  
  
    - 中序：左中右
  
      - ```go
        //迭代方式
        func inorderTraversal(root *TreeNode) []int {
        	if root == nil {
        		return nil
        	}
        	stack := []*TreeNode{}
        	record := []int{}
        	cur := root
        	for len(stack) != 0 || cur != nil {
        		if cur != nil {
        			stack = append(stack, cur)
        			cur = cur.Left
        		} else {
        			lens := len(stack)
        			cur = stack[lens-1]
        			stack = stack[:lens-1]
        			record = append(record, cur.Val)
        			cur = cur.Right
        		}
        	}
        	return record
        }
        //递归方式
        func inorderTraversal(root *TreeNode) []int {
        	if root == nil {
        		return nil
        	}
        	tmp := []int{}
        	tmp = append(tmp, inorderTraversal(root.Left)...)
        	tmp = append(tmp, root.Val)
        	tmp = append(tmp, inorderTraversal(root.Right)...)
        	return tmp
        }
        ```
  
  
    - 后序：左右中
  
      - ```go
        //递归遍历
        func postorderTraversal(root *TreeNode) []int {
        	if root == nil {
        		return nil
        	}
        	tmp := []int{}
        	tmp = append(tmp, postorderTraversal(root.Left)...)
        	tmp = append(tmp, postorderTraversal(root.Right)...)
        	tmp = append(tmp, root.Val)
        	return tmp
        }
        //迭代遍历
        ```
  


- 广度遍历（层级遍历：迭代遍历）


  - ```go
    func levelOrder(root *TreeNode) [][]int {
    	stack := []*TreeNode{}
    	record := [][]int{}
    	stack = append(stack, root)
    	for len(stack) != 0 {
    		cur := stack[0]
    		tmp := []int{}
    		lens := len(stack)
    		for lens != 0 {
    			lens--
    			tmp = append(tmp, stack[0].Val)
    			stack = stack[1:]
    			if cur.Left != nil {
    				stack = append(stack, cur.Left)
    			}
    			if cur.Right != nil {
    				stack = append(stack, cur.Right)
    			}
    		}
    		record = append(record, tmp)
    	}
    	return record
    }
    ```

#### 最大深度，高度

高度：二叉树中的任意一个节点到 叶子节点 的距离

深度：叶子节点 到 跟节点 的距离

#### 总结

二叉树可以日常看成数组结构，用以简化思考难度

二叉树中间节点用来处理逻辑，两侧节点用来处理递归逻辑

二叉树的遍历方式并不是固定的前、中、后三种遍历方式，要灵活处理，各种变异的遍历方式

## 回溯

回溯算法都可以抽象成一个树形结构

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。

回溯是递归的副产品，只要有递归就会有回溯。

#### 排列与组合

- 最小粒度切割



## 贪心算法

贪心的本质是选择每一阶段的局部最优，从而达到全局最优



## 动态规划

动态规划中每一个状态一定是由上一个状态推导出来的

#### 动规步骤

1. 确定 dp[i] 的含义
2. 确定递推公式
3. 初始化 dp 数组
4. 遍历顺序
5. 打印 dp[i]

### 背包问题




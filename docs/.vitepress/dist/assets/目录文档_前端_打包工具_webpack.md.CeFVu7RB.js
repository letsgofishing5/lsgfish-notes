import{_ as i,c as r,o,a4 as e,m as l,a}from"./chunks/framework.CXKHhAhX.js";const q=JSON.parse('{"title":"总结 Webpack","description":"","frontmatter":{},"headers":[],"relativePath":"目录文档/前端/打包工具/webpack.md","filePath":"目录文档/前端/打包工具/webpack.md"}'),t={name:"目录文档/前端/打包工具/webpack.md"},u=e('<h1 id="总结-webpack" tabindex="-1">总结 Webpack <a class="header-anchor" href="#总结-webpack" aria-label="Permalink to &quot;总结 Webpack&quot;">​</a></h1><h2 id="webpack-基本概念" tabindex="-1">Webpack 基本概念 <a class="header-anchor" href="#webpack-基本概念" aria-label="Permalink to &quot;Webpack 基本概念&quot;">​</a></h2><h4 id="_1-entry-入口" tabindex="-1">1. entry 入口 <a class="header-anchor" href="#_1-entry-入口" aria-label="Permalink to &quot;1. entry 入口&quot;">​</a></h4><ul><li>以某个文件为入口开始打包</li><li>分类 <ul><li>单入口 String <ul><li>只会输出一个文件</li></ul></li><li>多入口 Array / Object <ul><li>Array 只会输出一个文件</li><li>Object 会输出多个文件 ==&gt; 多页应用(MPA)</li></ul></li></ul></li></ul><h4 id="_2-output-输出" tabindex="-1">2. output 输出 <a class="header-anchor" href="#_2-output-输出" aria-label="Permalink to &quot;2. output 输出&quot;">​</a></h4><ul><li>打包后资源输出到哪里去</li><li>输出的文件名叫什么</li></ul><h4 id="_3-loader-加载器" tabindex="-1">3. loader 加载器 <a class="header-anchor" href="#_3-loader-加载器" aria-label="Permalink to &quot;3. loader 加载器&quot;">​</a></h4><ul><li>webpack 本身只能识别 json、js 模块，其他模块一旦加载就会报错</li><li>需要借助 loader 帮助 webpack 识别其它识别不了的模块</li></ul><h4 id="_4-plugins-插件" tabindex="-1">4. plugins 插件 <a class="header-anchor" href="#_4-plugins-插件" aria-label="Permalink to &quot;4. plugins 插件&quot;">​</a></h4><ul><li>loader 功能有限，要想做功能更加强大的工作交给插件</li><li>比如在页面中自动引入打包生成的js/css, 压缩css, 拷贝文件等</li></ul><h4 id="_5-mode" tabindex="-1">5. mode <a class="header-anchor" href="#_5-mode" aria-label="Permalink to &quot;5. mode&quot;">​</a></h4><ul><li>模式：开发环境（development）和生产环境（production）</li><li>提供一系列默认配置, 用于简化配置</li></ul><h2 id="webpack-基本配置" tabindex="-1">Webpack 基本配置 <a class="header-anchor" href="#webpack-基本配置" aria-label="Permalink to &quot;Webpack 基本配置&quot;">​</a></h2><h4 id="_1-处理js文件" tabindex="-1">1. 处理JS文件 <a class="header-anchor" href="#_1-处理js文件" aria-label="Permalink to &quot;1. 处理JS文件&quot;">​</a></h4><ul><li>eslint-loader <ul><li>在package.json中配置eslintConfig来指示eslint-loader到底要干什么事</li><li>enfore: &#39;pre&#39; 优先执行</li></ul></li><li>babel-loader <ul><li>在webpack配置中配置babel来指示babel-loader到底要干什么事</li><li>babel.config.js: 配置webpack的preset与plugin</li></ul></li></ul><h4 id="_2-处理vue文件" tabindex="-1">2. 处理Vue文件 <a class="header-anchor" href="#_2-处理vue文件" aria-label="Permalink to &quot;2. 处理Vue文件&quot;">​</a></h4><ul><li>vue-loader</li></ul><h4 id="_3-处理jsx文件" tabindex="-1">3. 处理JSX文件 <a class="header-anchor" href="#_3-处理jsx文件" aria-label="Permalink to &quot;3. 处理JSX文件&quot;">​</a></h4><ul><li>babel-loader</li><li>presets: [&#39;@babel/preset-react&#39;]</li></ul><h4 id="_4-处理css文件" tabindex="-1">4. 处理CSS文件 <a class="header-anchor" href="#_4-处理css文件" aria-label="Permalink to &quot;4. 处理CSS文件&quot;">​</a></h4><ul><li>开发环境：创建style标签插入样式 <ul><li>style-loader</li><li>css-loader</li><li>postcss-loader</li><li>less-loader / sass-loader / stylus-loader</li></ul></li><li>生产环境：提取单独css文件，将来通过link引入 <ul><li>MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）</li><li>css-loader</li><li>postcss-loader</li><li>less-loader / sass-loader / stylus-loader</li></ul></li></ul><h4 id="_5-处理html文件" tabindex="-1">5. 处理HTML文件 <a class="header-anchor" href="#_5-处理html文件" aria-label="Permalink to &quot;5. 处理HTML文件&quot;">​</a></h4><ul><li>目标: 自动引入打包生成的js/css</li><li>html-webpack-plugin</li></ul><h4 id="_6-处理图片-字体-音视频文件" tabindex="-1">6. 处理图片/字体/音视频文件 <a class="header-anchor" href="#_6-处理图片-字体-音视频文件" aria-label="Permalink to &quot;6. 处理图片/字体/音视频文件&quot;">​</a></h4><ul><li>url-loader / file-loader</li><li>limit: 10000 小于10kb一下的图片会被base64处理</li></ul><h2 id="webpack-优化手段" tabindex="-1">Webpack 优化手段 <a class="header-anchor" href="#webpack-优化手段" aria-label="Permalink to &quot;Webpack 优化手段&quot;">​</a></h2><h4 id="_1-优化打包构建速度" tabindex="-1">1. 优化打包构建速度 <a class="header-anchor" href="#_1-优化打包构建速度" aria-label="Permalink to &quot;1. 优化打包构建速度&quot;">​</a></h4><h5 id="hmr-热模块替换" tabindex="-1">HMR 热模块替换 <a class="header-anchor" href="#hmr-热模块替换" aria-label="Permalink to &quot;HMR 热模块替换&quot;">​</a></h5>',28),s=l("ul",null,[l("li",null,[a("为什么要用？ "),l("ul",null,[l("li",null,"默认情况下，一旦修改了代码，全部代码重新编译刷新，速度慢（全体刷新）")])]),l("li",null,[a("有什么作用？ "),l("ul",null,[l("li",null,"只更新修改的模块，其他模块不变（局部更新）")])]),l("li",null,[a("怎么使用？ "),l("ul",null,[l("li",{"hot:":"",true:""},"devServer:"),l("li",null,"new webpack.HotModuleReplacementPlugin()")])]),l("li",null,[a("注意： "),l("ul",null,[l("li",null,"默认情况下只有样式文件有HMR功能（style-loader），JS是没有的")])]),l("li",null,[a("开启JS的HMR功能： "),l("ul",null,[l("li",null,"手写JS代码 --> module.hot.accpet('模块路径', () => {})"),l("li",null,"在Vue使用 --> vue-loader"),l("li",null,"在React使用 --> react-hot-loader")])])],-1),h=e('<h5 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h5><ul><li>eslint和babel两个任务处理JS文件，时间一般会比较长，为了让其重新构建速度更快, 可以使用缓存。</li><li>eslint --&gt; cache: true</li><li>babel --&gt; cacheDirectory: true</li><li>cache-loader放置在要缓存loader的前面</li><li>注意：一般只针对耗时长的任务：eslint-loader/babel-loader/vue-loader</li></ul><h5 id="oneof" tabindex="-1">oneOf <a class="header-anchor" href="#oneof" aria-label="Permalink to &quot;oneOf&quot;">​</a></h5><ul><li>作用： <ul><li>让模块只被一个loader处理，其他的就不看了(原本所有都会判断一下)</li><li>能够提升打包速度</li></ul></li><li>注意： <ul><li>eslint-loader: 处理js, 需要先执行, 将其定义在oneOf的外面</li><li>babel-loader: 处理js, 后执行, 将其定义在oneOf的内部</li></ul></li></ul><h5 id="多进程打包" tabindex="-1">多进程打包 <a class="header-anchor" href="#多进程打包" aria-label="Permalink to &quot;多进程打包&quot;">​</a></h5><ul><li>过去: happyPack</li><li>现在: thread-loader</li><li>用法和cache-loader差不多，放在要使用loader前面</li><li>作用：开启多进程处理前面的任务，提升打包速度</li><li>注意：每个进程开启和通信都有开销，一般只针对耗时长的任务：babel-loader</li></ul><h4 id="_2-优化打包代码体积和性能" tabindex="-1">2. 优化打包代码体积和性能 <a class="header-anchor" href="#_2-优化打包代码体积和性能" aria-label="Permalink to &quot;2. 优化打包代码体积和性能&quot;">​</a></h4><h5 id="兼容性处理" tabindex="-1">兼容性处理 <a class="header-anchor" href="#兼容性处理" aria-label="Permalink to &quot;兼容性处理&quot;">​</a></h5><ul><li>JS <ul><li>ES6由二个部分 <ul><li>新语法: const/let/箭头函数/解构赋值/对象简写</li><li>新API: Promise / 数组新方法/ 对象新方法</li></ul></li><li>babel-loader presets: [&#39;@babel/preset-env&#39;] 问题就是只能编译语法, 不能处理新API</li><li>@babel/polyfill 做API兼容，问题是体积太大了</li><li>core-js3 在@babel/preset-env基础上，增加了useBuiltIns: &#39;usage&#39;来实现按需加载</li><li>指定浏览器版本或占有率配置, 进一步减小打包文件: 只打包使用了且浏览器没有实现的</li></ul></li><li>CSS <ul><li>postcss-loader</li><li>在package.json中指定browserslist来指示postcss-loader兼容性做到什么程度</li></ul></li></ul><h5 id="tree-shaking-摇树" tabindex="-1">tree shaking( 摇树) <a class="header-anchor" href="#tree-shaking-摇树" aria-label="Permalink to &quot;tree shaking( 摇树)&quot;">​</a></h5><ul><li>去除没有使用的JS代码</li><li>必须使用ES6模块化（需要禁止@babel/preset-env转换ES6模块化语法 modules: false）</li><li>开启webpack的生产模式（内部启用TerserPlugin，用来压缩JS代码的插件，tree shaking功能就是这个插件完成的）</li><li>在package.json配置sideEffects来指定哪些文件需要进行tree shaking</li></ul><h5 id="code-split-代码分割-lazy-loading-懒加载" tabindex="-1">code split 代码分割 / lazy loading 懒加载 <a class="header-anchor" href="#code-split-代码分割-lazy-loading-懒加载" aria-label="Permalink to &quot;code split 代码分割 / lazy loading 懒加载&quot;">​</a></h5><ul><li>作用： <ul><li>抽取公共代码</li><li>拆分多个文件，减少单个文件体积（避免单次请求时间过长）</li></ul></li><li>配置： <ul><li>多入口 + optimization <ul><li>将node_modules抽取成单独模块</li><li>将多入口的公共模块也抽取成单独模块</li></ul></li><li>单入口 + optimization + import <ul><li>将node_modules抽取成单独模块</li><li>动态导入语法import就能将某些文件抽取成单独模块</li></ul></li><li>import()动态引入模块 <ul><li>原生 JS: 在需要的回调函数中动态加载模块, import(模块).then()</li><li>Vue: () =&gt; import(&#39;./Foo.vue&#39;), 实现路由组件懒加载</li><li>React: Suspence +lazy(() =&gt; import(&#39;./SomeComponent&#39;)), 实现路由组件懒加载</li></ul></li></ul></li></ul><h5 id="preload-和-prefetch-预加载" tabindex="-1">preload 和 prefetch 预加载 <a class="header-anchor" href="#preload-和-prefetch-预加载" aria-label="Permalink to &quot;preload 和 prefetch 预加载&quot;">​</a></h5><ul><li>作用： <ul><li>让资源提前加载</li></ul></li><li>区别： <ul><li>preload 让当前页面的要使用资源加载（延后加载）</li><li>prefetch 让后面要使用资源提前加载（当前不需要使用）</li></ul></li><li>使用： <ul><li>import(/*webpackChunkName: xxx webpackPrefetch: true */&#39;./xxx&#39;)</li><li>import(/*webpackChunkName: xxx webpackPreload: true */&#39;./xxx&#39;) // 没有效果</li><li>问题：兼容性较差</li></ul></li><li>使用Chrome团队提供的一个工具包: preload-webpack-plugin <ul><li>npm i -D preload-webpack-plugin@next // 必须是最新的下一个版本</li><li>对异步模块包使用: prefetch</li><li>对同步模块包使用: preload</li></ul></li></ul><h5 id="浏览器cache-缓存" tabindex="-1">浏览器cache/缓存 <a class="header-anchor" href="#浏览器cache-缓存" aria-label="Permalink to &quot;浏览器cache/缓存&quot;">​</a></h5><ul><li><p>hash</p><ul><li>webpack每次构建都会生成一个新的且唯一的hash</li><li>问题：只要webpack重新构建，所有文件的hash都会发生变化，缓存就会失效</li></ul></li><li><p>chunkhash</p><ul><li>打包属于同一个chunk，就共享同一个hash</li><li>问题：样式文件被css-loader打包js文件中，导致样式文件和js文件属于同一个chunk，共享同一个hash</li><li>一旦样式文件发生变化，js文件也会变</li></ul></li><li><p>contenthash</p><ul><li>根据文件的内容来成hash，所以只要文件内容不一样，hash就不一样</li><li>问题： <ul><li>比如A模块有一个依赖，是B模块，那么A模块内部就会保存B模块hash值，</li><li>一旦B模块发生变化，B模块的hash值就会变，导致A模块内部保存B模块hash值也发生改变</li><li>此时A模块文件内容发生变化，它的hash值也会变</li></ul></li><li>解决： <ul><li>runtimechunk: true 将A模块保存的B模块hash值存到runtime文件中，这样A模块内部就没有B模块的hash值了，就不会因为B模块的修改而修改</li></ul></li></ul></li></ul>',17),n=[u,s,h];function c(d,b,p,k,m,_){return o(),r("div",null,n)}const x=i(t,[["render",c]]);export{q as __pageData,x as default};

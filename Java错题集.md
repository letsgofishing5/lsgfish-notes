# Java错题集

## 常见概念错误

##### 1、标识符

> ```java
> Java标识符命名规范是：
> 1``）只能包含字母a-zA-Z，数字``0``-``9``，下划线_和美元符号$；
> 2``）首字母不能为数字；
> 3``）关键字和保留字不能作为标识符。
> ```

###### 2、方法的加载顺序

> 类的初始化过程也就是方法执行的过程。
>
> 父类的静态域-子类的静态域 父类的非静态域-父类的构造函数 子类的非静态域-子类的构造函数 规律就是 父类先于子类 静态的先于非静态的
>
> 其中静态域包含静态代码块与静态方法，这个谁在前面，则先执行谁。

## 运算符错误

### 1、除法：/ %

```java
	13%5=3 //这是取余数，又称取模
    13/5=2 //这是取整数
```

## JSP问题

##### JSP表达式写法：

```java
	<%= expression %>
```

## 内存

### 栈内存

## 锁

#### 互斥锁

> 概念：互斥锁提供一个可以在同一时间，只让一个线程访问临界资源的的操作接口。互斥锁(Mutex)是个提供线程同步的基本锁。让上锁后，其他的线程如果想要锁上，那么会被***\*阻塞\****，直到锁释放后（说明，一般会把访问共享内存这段代码放在上锁程序之后。）。
>
> 如果，在锁释放后，有多个线程被阻塞，那么，所有的被阻塞的线程会被设为可执行状态。第一个执行的线程，取得锁的控制权，上锁。其他的线程继续阻塞。

## 集合

### HashMap

##### HashMap中是用哪些方法来解决哈希冲突的？

> 1.开放地址法
>
> 2.链地址法（拉链法）
>
> 3.再散列
>
> 4.建立一个公共溢出区

## 对象

##### Java对象的创建方式

> 1. 使用 new 关键字（最常用）： ObjectName obj = new ObjectName();
> 2. 使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); 
> 3. 使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance();
> 4. 使用对象克隆clone()方法： ObjectName obj = obj.clone(); 
> 5. 使用反序列化（ObjectInputStream）的readObject()方法： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }

##  接口

##### Comparable和Comparator区别是什么？

> 1. Comparable是排序接口，若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。
>
> 2. Comparator是比较接口,我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator来新建一个比较器，然后通过这个比较器对类进行排序
>
>    注意：1、若一个类要实现Comparator接口：它一定要实现compare(T o1, T o2) 函数，

##### 重载与重写

> 1. 重写：**发生在继承或实现的过程中，在方法名，参数列表，返回类型(除了子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，** 对方法体进行修改或重写，这就是重写。但要注意**子类函数的访问修饰权限不能小于父类的。**
> 2. 重载：在一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**

## 网络

##### http/2相比http/1.1有什么新特性？

## 反射

##### 反射的本质

> ​	选项反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法，而不是修剪类


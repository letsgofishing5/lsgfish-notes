# 算法

### 链表

1. 单向链表常用解决方案就是：**虚拟头节点**



### 哈希表

当给你一个元素，判断这个元素是否在这个集合里出现过的时候，适合用哈希表解决问题



### 栈与队列

栈适合做相邻元素之间的关联处理



### 二叉树

#### 存储方式

- 链式存储（树）
- 线性存储（数组）

#### 遍历方式

- 深度遍历（递归遍历，迭代遍历）：所有递归方法都可以使用**模拟栈**来迭代实现

  - 前序：中左右

    - ```go
      //递归遍历
      func preorderTraversal(root *TreeNode) []int {
      	if root == nil {
      		return nil
      	}
      	tmp := []int{}
      	tmp = append(tmp, root.Val)
      	tmp = append(tmp, preorderTraversal(root.Left)...)
      	tmp = append(tmp, preorderTraversal(root.Right)...)
      	return tmp
      }
      //迭代遍历
      func preorderTraversal(root *TreeNode) []int {
      	stack := []*TreeNode{}
      	record := []int{}
      	stack = append(stack, root)
      	for len(stack) != 0 {
      		cur := stack[len(stack)-1]
      		stack = stack[:len(stack)-1]
      		if cur != nil {
      			record = append(record, cur.Val)
      			if cur.Right != nil {
      				stack = append(stack, cur.Right)
      			}
      			if cur.Left != nil {
      				stack = append(stack, cur.Left)
      			}
      		}
      	}
      	return record
      }
      ```
  
  
    - 中序：左中右
  
      - ```go
        //迭代方式
        func inorderTraversal(root *TreeNode) []int {
        	if root == nil {
        		return nil
        	}
        	stack := []*TreeNode{}
        	record := []int{}
        	cur := root
        	for len(stack) != 0 || cur != nil {
        		if cur != nil {
        			stack = append(stack, cur)
        			cur = cur.Left
        		} else {
        			lens := len(stack)
        			cur = stack[lens-1]
        			stack = stack[:lens-1]
        			record = append(record, cur.Val)
        			cur = cur.Right
        		}
        	}
        	return record
        }
        //递归方式
        func inorderTraversal(root *TreeNode) []int {
        	if root == nil {
        		return nil
        	}
        	tmp := []int{}
        	tmp = append(tmp, inorderTraversal(root.Left)...)
        	tmp = append(tmp, root.Val)
        	tmp = append(tmp, inorderTraversal(root.Right)...)
        	return tmp
        }
        ```
  
  
    - 后序：左右中
  
      - ```go
        //递归遍历
        func postorderTraversal(root *TreeNode) []int {
        	if root == nil {
        		return nil
        	}
        	tmp := []int{}
        	tmp = append(tmp, postorderTraversal(root.Left)...)
        	tmp = append(tmp, postorderTraversal(root.Right)...)
        	tmp = append(tmp, root.Val)
        	return tmp
        }
        //迭代遍历
        ```
  


- 广度遍历（层级遍历：迭代遍历）


  - ```go
    func levelOrder(root *TreeNode) [][]int {
    	stack := []*TreeNode{}
    	record := [][]int{}
    	stack = append(stack, root)
    	for len(stack) != 0 {
    		cur := stack[0]
    		tmp := []int{}
    		lens := len(stack)
    		for lens != 0 {
    			lens--
    			tmp = append(tmp, stack[0].Val)
    			stack = stack[1:]
    			if cur.Left != nil {
    				stack = append(stack, cur.Left)
    			}
    			if cur.Right != nil {
    				stack = append(stack, cur.Right)
    			}
    		}
    		record = append(record, tmp)
    	}
    	return record
    }
    ```

- 统一迭代方式


  - ```go
    
    ```



## 动态规划

[视频地址](https://www.bilibili.com/video/BV13Q4y197Wg/?spm_id_from=333.999.0.0&vd_source=4db4edf8e68a4ceac9f0a41212e6f026)

![image-20230525172821214](./算法.assets/image-20230525172821214.png)

### 背包问题

# 点

## KMP




# 面试问题整理

## HTML + CSS

**单行文本溢出**

```css
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
```

**多行文本溢出**

```css
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2; /*2*/
-webkit-box-orient: vertical;
```

### 圣杯双飞翼

### flex布局

- flex:1，单独给某一个子元素设置flex属性的时候可以提高当前flex的权重

#### 圣杯布局

- 圣杯特点简单记为：有头、有尾、包三列，圣杯布局中间有container大容器包裹着左、中、右三列区域
- 左、中、右是独立的三个区域，都处于一个层级

#### 双飞翼布局

- 左、中、右是独立的三个区域，中间区域属于最上面的层级



## JS基础和高级

### 字符串强转数字

- +号
- *1
- `'123'>>>0`位移符，先转二进制向右位移，左边不足的位用0补齐

### **面向对象**

#### **作用域**

1. 什么是作用域

   用来规定代码作用的范围及变量查询的范围

2. 作用域的作用

   隔离变量, 防止命名冲突

3. 作用域什么时候产生及销毁

   - 代码定义的时候产生

   - 函数执行完销毁的是变量对象而不是作用域
   - 作用域从代码定义的时候就一直在，除非没有当前代码

4. **作用域链**

   - 查找变量的时候现在当前作用域的变量对象中查找，如果有就使用，如果没有会继续去上级作用域查找，直到找到全局作用域，如果还没有就报错，报错内容： xxx is not defined, 查找的过程就是沿着作用域链查找
   - 本质: 是一个数组，数组包含上级所有的变量对象

#### **执行上下文环境**

js代码在正式执行之前js引擎会先做一些准备工作

1. 创建执行上下文环境
2. 创建一个空的对象(执行上下文对象)，该对象用于收集当前作用域的：变量，函数，函数的参数
3. 确认this的指向
4. 创建当前环境的作用域链

#### 闭包

- **闭包的形成条件**

  1. 函数嵌套

  2. 内部函数引用外部函数的局部变量

  3. 内部函数被使用

     特例： 如果内部函数没有被使用，外部函数在预解析的时候不会定义该内部函数

- **什么是闭包**

  1. 闭包是抽象的概念
  2. 闭包其实指的就是满足一定的条件下(闭包的形成条件)，会形成一个闭包的容器(对象)
  3. 该对象用于收集内部函数使用的外部函数的变量
  4. 该对象在内部函数调用的时候供内部函数使用
  5. 因为闭包形成的闭合对象保存在内部函数的[[scopes]]中

#### 原型

- **什么是原型对象**

  1. 每个函数的prototype指向的是其显示原型对象

  2. 每个实例的`__proto__`指向的是其隐式原型对象

  3. 实例的隐式原型对象 === 其构造函数的显示原型对象

- **原型链**

  1. 对象查找属性的时候现在自身查找，如果自身没有沿着`__proto__`这条链查找
  2. 如果有就使用，如果没有就继续向上查找直到找到Object.prototype，如果还没有就返回undefined

- **原型继承**

  1. 子类的原型成为父类的实例
  2. 需要执行子类的构造属性constructor

- **借用构造函数继承**

  不是真正意义上的继承，只是简化子类构造函数的代码

- 组合继承

  原型继承 + 借用构造函数继承



## JS周边

	### 队列

- 宏队列：dom事件回调、ajax回调、定时器回调
- 微队列：promise回调  mutation回调
- 执行顺序：同步代码 --> 微任务 --> 宏任务

### Promise

- promise + async 用同步的流程表达异步的行为

#### 面试题

```js
setTimeout(() => {
    console.log("0")
  }, 0)
  new Promise((resolve,reject)=>{
    console.log("1")
    resolve()
  }).then(()=>{        
    console.log("2")
    new Promise((resolve,reject)=>{
      console.log("3")
      resolve()
    }).then(()=>{      
      console.log("4")
    }).then(()=>{       
      console.log("5")
    })
  }).then(()=>{  
    console.log("6")
  })

  new Promise((resolve,reject)=>{
    console.log("7")
    resolve()
  }).then(()=>{         
    console.log("8")
  })
T	1	7
W	2 3	 8  4  6  5	
H	0
```

### 深浅拷贝

浅拷贝

```js
/* 
只有对象或数组才进行拷贝, 其它类型直接返回
*/
const aUtils = {
  /* 方法一: 利用ES6语法 */
  clone1 (target) {
    if (target!==null && typeof target==='object') { // 非函数的对象
      if (Array.isArray(target)) {
        // return [...target]
        // return target.slice()
        // return target.filter(item => true)
        // return target.map(item => item)
      } else {
        return {...target}
      }
    } else {
      return target
    }
  },
```

深拷贝

```js
/* 
1). 大众乞丐版
    问题1: 函数属性会丢失   原因: json字符串数据是不存在函数, 函数属性就会丢失
    问题2: 循环引用会出错   原因: 转换为json字符串是会产生死循环查找, 报错
利用JSON转换成json字符串, 再解析回来
*/
deepClone1 (target) {
  if (target!==null && typeof target==='object' ) {
    return JSON.parse(JSON.stringify(target))
  } else {
    return target
  }
},
```

```js
 /* 
2). 面试基础版本
    解决问题1: 函数属性还没丢失
    问题2: 循环引用会出错  没有解决: 它会同个对象或数据进行不断拷贝
*/
deepClone2 (target) {
  if (target!==null && typeof target==='object') { // 非函数的对象
    // 创建一个新的空容器
    const clone = Array.isArray(target) ? [] : {}

    // 遍历target中所有数据, 依次添加到新容器
    for (const key in target) {  // key是对象的属性名或数组的下标
      if (target.hasOwnProperty(key)) { // 如果是容器自身的才需要处理
        clone[key] = aUtils.deepClone2(target[key]) // 对属性值进行克隆处理后保存
      }
    }
    return clone
  } else {
    return target
  }
},
```

```js
/* 
3). 面试加强版本
  解决问题2: 循环引用正常

  缓存的容器
    问题1: 什么结构的?  Map, key为target, value是对应的拷贝对象
    问题2: 保存什么数据  key是target, value是target对应的拷贝对象
  注意: 在整个递归调用过程中, 只有一个map在反复使用
*/

deepClone3 (target, map=new Map()) {

  if (target!==null && typeof target==='object') { // 非函数的对象
   // const map = new Map()  // 用来缓存target与其对应的拷贝对象的容器   // 不能在这里
    // 从缓存中取出对应的拷贝对象,如果有了, 直接返回它
    let clone = map.get(target)
    if (clone) return clone

    // 如果没有, 创建一个新拷贝空容器, 缓存起来
    clone = Array.isArray(target) ? [] : {}
    map.set(target, clone)

    // 遍历target中所有数据, 依次添加到新容器
    for (const key in target) {  // key是对象的属性名或数组的下标
      if (target.hasOwnProperty(key)) { // 如果是容器自身的才需要处理
        clone[key] = aUtils.deepClone3(target[key], map) // 对属性值进行克隆处理后保存
      }
    }
    return clone
  } else {
    return target
  }
},
```

```js
/* 
4). 面试加强版本2(优化遍历性能)
    数组: while | for | forEach() 优于 for-in | keys()&forEach() 
    对象: for-in 与 keys()&forEach() 差不多
*/
deepClone4 (target, map=new Map()) {

  if (target!==null && typeof target==='object') { // 非函数的对象
   // const map = new Map()  // 用来缓存target与其对应的拷贝对象的容器   // 不能在这里
    // 从缓存中取出对应的拷贝对象,如果有了, 直接返回它
    let clone = map.get(target)
    if (clone) return clone

    // 如果没有, 创建一个新拷贝空容器, 缓存起来
    if (Array.isArray(target)) {
      clone = []
      map.set(target, clone)
      // 遍历target数组中所有元素, 依次添加到新容器
      target.forEach((item, index) => {
        // clone.push(aUtils.deepClone4(item, map))
        clone[index] = aUtils.deepClone4(item, map)
      })

    } else {
      clone = {}
      map.set(target, clone)
      // 遍历target对象中所有数据, 依次添加到新容器
      for (const key in target) {  // key是对象的属性名或数组的下标
        if (target.hasOwnProperty(key)) { // 如果是容器自身的才需要处理
          clone[key] = aUtils.deepClone4(target[key], map) // 对属性值进行克隆处理后保存
        }
      }
    }

    return clone
  } else {
    return target
  }
},
```





## git操作

- git config --global credential.helper store (记住用户和密码)

- 分支操作

  ​	拉取远程新分支到本地

  ​	git pull (如果分支是在clone后创建的才需要执行)

  ​	git checkout -b dev origin/dev

- 版本注释一般规范
  feat 特性：新增功能

  docs 文档：新增文档

  fix 修复 Bug

- xiongjian分支到本地仓库xiongjian分支上

  git fetch origin xiongjian:xiongjian 拉取远程仓库

## 数组

### 数组扁平化

1. 使用数组原型中的falt方法

   ```js
   let arr = [1, 2, 3, [4, 5, 6, [7, 8, [9, 10, 11]]]];
   arr.flat(Infinity);
   ```

2. 如果都是数字，可再进行遍历讲字符串转为数字

   ```js
   let arr = [1, 2, 3, [4, 5, 6, [7, 8, [9, 10, 11]]]];
   arr.toString().split(',')
   ```

3. 三点运算符

   ```js
   function flatten(arr) {
       while (arr.some(item => Array.isArray(item))) {
           arr = [].concat(...arr);
       }
       return arr;
   }
   ```

### 数组去重

1. 双重循环

   ```js
   var newArr = [];
   var flag = true;
   for(var i = 0; i < arr.length; i++){
       //外部循环取数
       for(var j = 0; j < newArr.length; j++){
           //内层循环是为了和外层取的数取对比，看看新数组当中有没有
           if(arr[i] == newArr[j]){
               flag = false;
               break;
           }
       }
   
       if(flag){
           newArr[newArr.length] = arr[i];
       }
       flag = true;
   }
   ```

2. indexOf

   ```js
   function removeRepeat(array) {
       var res = [];
       for (var i = 0, len = array.length; i < len; i++) {
           var current = array[i];
           if (res.indexOf(current) === -1) {
               res.push(current)
           }
       }
       return res;
   }
   ```

3. filter

   ```js
   function removeRepeat(array) {
       var res = array.filter(function(item, index){
           return array.indexOf(item) === index;
       })
       return res;
   }
   ```

4. Object 键值对

   ```js
   var array = [1, 2, 1, 1, '1'];
   function removeRepeat(array) {
       var obj = {};
       return array.filter(function(item, index, array){
           return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)	// 因为1 和 '1' 是不同的，所以使用typeof item + item 拼成字符串作为 key 值
       })
   }
   ```

5. set方法

   ```js
   function removeRepeat(array) {
      return [...new Set(array)];
   }
   ```


### 数组翻转

1. 循环

   ```js
   for(var i = 0; i < arr.length; i++){
       var temp = arr[i];
       arr[i] = arr[arr.length - 1 - i]
       arr[arr.length - 1 - i] = temp;
   }
   ```

2. 使用原型中的reverse方法

   ```js
   let array = [1, 2, 3, 4, 5]
   array.reverse() 
   ```

### 排序算法

#### 冒泡算法

```js
let arr = [2, 3, 5, 1, 4, 7, 6];
// 冒泡算法
function arrSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 不使用第三方变量交换两个变量的值
        arr[j] = arr[j] + arr[j + 1];
        arr[j + 1] = arr[j] - arr[j + 1];
        arr[j] = arr[j] - arr[j + 1];
      }
    }
  }
  return arr;
}
```

#### 快速排序

```js
function quickSort(arr) {
  // 递归结束的条件
  if(arr.length < 2){
    return arr
  }
  // 获取中间值
  let flag = Math.floor(arr.length / 2);
  let flagValue = arr.splice(flag, 1)[0];
  
  let leftArr = [];
  let rightArr = [];
  for (var i = 0; i < arr.length; i++) {
    var arrItem = arr[i];
    
    if(arrItem > flagValue){
      rightArr.push(arrItem)
    }else {
      leftArr.push(arrItem)
    }
  }
  
  leftArr = quickSort(leftArr);
  rightArr = quickSort(rightArr);
  return [...leftArr, flagValue, ...rightArr]
}
```



## 跨域问题

- 跨域：跨域的安全限制都是对浏览器端来说的，服务器端是不存在跨域安全限制的。浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。

1. jsonp解决跨域（只支持get请求）

   jsonp的原理：利用就是利用`script`标签没有跨域限制，可以通过`script`标签的src属性发送`GET`请求。

   实现步骤：

   1. 在前端预先定义好一个带参数的函数用来接受后端传来的数据。
   2. 在后端启动一个server服务，将要传的数据以定义好了的函数名加上返回结果的方式传给前端。
   3. 利用`script`标签自动解析函数获取数据

### 自定义jsonp

```js
myJsonp = function(url,data,callback){
            
    var fnName = 'myJsonp_' + Math.random().toString().replace('.','');
    
    //定义一个全局回调函数
    window[fnName] = callback;
    
    //初始化序列化参数
    var querystring = '';
    for(var attr in data){
        querystring += attr + '=' + data[attr] + '&';
    }
    //动态创建script标签
    var script = document.createElement('script');
    //后台接受回调函数，并调用
    script.src = url + '?' + querystring + 'callback=' + fnName;
  
    //处理完毕之后,删除script标签，否则多次请求，页面会存在多个script标签
    script.onload = function(){    
        document.body.removeChild(script);
    }
    
    document.body.appendChild(script);
}
```



## webpack

### 基础

- entry 入口

  指示 webpack 从哪个文件开始打包

- output 输出

  指示 webpack 将打包后的文件输出到哪里去

- loader 加载器

  帮助 webpack 解析它解析不了的模块（将其他模块解析成 webpack 能识别的模块，这样才能打包）

  还有其他功能：多进程打包...

- plugin 插件

  能够功能更加强大的事

  将现有库包装成 webpack 能够识别的功能模块，从而加载使用

- mode 模式

  模式（development/production）

  区别：设置不同 NODE_ENV，启用不同的插件

### 其他配置

- resolve 解析：帮助 webpack 解析模块

  alias 配置路径别名

  extensions 配置自动补全文件扩展名

  modules 配置 引入 node_modules 库，node_modules 文件夹去哪找

- optimization 优化

- devServer 开发服务器

### 兼容性处理

- JS 兼容性处理 babel
- CSS 兼容性处理，使用 postcss-loader 做 css 兼容性处理

### 树摇（**tree shaking**）

- 树摇：去除无用的 JS 代码

- 配置

  必须使用 ES6 模块化

  开启 mode: production

### 缓存

- 客户端缓存服务器请求的资源（js/css/图片...）

  - 强制缓存（不会重新访问服务器，直接读取缓存）

    问题：如果资源在缓存期间内，是没办法更新的~

  - 协商缓存（每次都会重新访问服务器，由服务器来决定要不要走缓存，304）

- hash webpack 打包生成的，所以资源共享 hash 值

  问题：如果改动一个资源，所有资源的 hash 都变~导致其他资源缓存失效

- chunkhash 属于同一个 chunk，hash 值一样，不同 chunk，hash 值不一样

  问题：单入口样式文件因为 css-loader，会把样式文件打包到 js 中，此时就会和 js 共享同一个 hash 值，一旦改动 js 文件，css 文件缓存失效

- contenthash 根据文件内容来生成 hash，不同文件 hash 值不同

  新问题：如果 A 文件采用 import 进行代码分割文件 B，分割文件 B 一旦变化，那么 A 文件缓存失效

  原因是：A 文件保存 B 文件的 hash 值，一旦 B 文件变化，A 文件的 hash 值也要更新，从而导致 A 文件也变了

  解决：需要将 A 文件保存 B 文件的 hash 值单独提取出来，成单独文件，这样就不会影响 A 文件了

  ```js
  runtimeChunk: {
    name: (entry) => `runtime-${entry.name}.js`;
  }
  ```

### 关闭map

productionSourceMap: false, // 关闭map映射文件

## 网页输入网址后经历了哪些过程

1. 域名解析
2. 建立ＴＣＰ连接
3. 浏览器发送请求到服务器，服务器根据请求返回内容给浏览器
4. 浏览器解析渲染页面

## post常用的数据格式,form-data和json的区别

- json 对于接复杂对象比较方便，嵌套
- formdata 需要 String 转成对象，key value形式，数据量小，上传文件只能用formdata

## 图片懒加载原理,如何实现

- 先将img标签中的src链接设置为空，将真正的图片链接放在自定义属性（data-src），当js监听到图片元素进入到可视窗口的时候，将自定义属性中的地址存储到src中，达到懒加载的效果。

## window.onload和$(document).ready()区别

- window.onload是Javascript中得函数，意思是：等待网页中所有内容加载完毕之后（包括图片）
- 而$(documetn).ready()是在网页中的所有DOM结构绘制完毕之后就可以执行了，可能有与DOM关联的元素还没有加载完，所以相比之下更快一些；



## Vue 基础

### 组件间通信的方式

#### 组件间通信最基本方式: props

- 用来实现父子之间相互通信的最基本方式, 也是用得最多的方式
- 父 ==> 子, 传递的是非函数类型的属性
- 子 ==> 父, 传递的是函数类型的属性
- 存在问题：其它关系的组件使用props就会比较麻烦

#### vue自定义事件

**原生DOM事件**

绑定原生DOM事件监听的2种情况:

1. 在html标签上绑定DOM事件名的监听
2. 在组件标签上绑定DOM事件名的监听，只有加了.native修饰符，绑定的才是原生事件监听，而且会自动绑定到组件的根标签（内部用了事件委托），绑定的是最外层的div，$event代表浏览器分发事件时指定的数据event对象	

**vue自定义事件**

绑定vue自定义事件监听:

1. 只能在组件标签上绑定
2. 事件名是任意的, 可以与原生DOM事件名相同

- 不加.native，绑定的为自定义事件监听，且触发需要用$emit()触发，$event代表分发事件时指定的数据

监听函数调用

- $event: 就是分发自定义事件时指定的data数据
- $event可以是任意类型, 甚至可以没有
- this.$on('myEvent', (msg) => {})  绑定

vue的自定义事件作用

- 用来实现子向父组件通信, 功能相当于函数类型的props

**注意**：

- 绑定事件和触发事件的对象必须是同一个对象

#### 全局事件总线

- Vue原型对象上有3个事件处理的方法: $on() / $emit() / $off()

- 组件对象的原型对象是vm对象: 组件对象可以直接访问Vue原型对象上的方法

- 作用：实现任意组件间通信

- 编码实现

  ```js
  将入口js中的vm作为全局事件总线对象: 
  beforeCreate() {
      Vue.prototype.$bus = this
  }
  分发事件/传递数据的组件: this.$bus.$emit('eventName', data)
  处理事件/接收数据的组件: this.$bus.$on('eventName', (data) => {})
  ```

#### 组件间通信高级2: v-model深入理解

- 原生input上的v-model的本质: 动态的value属性与原生input事件监听,本质上等价于

  ```vue
  <input
    v-bind:value="searchText"
    v-on:input="searchText = $event.target.value"
  >
  ```

- 组件标签上的v-model的本质: 动态的value属性与自定义input事件监听

  ```vue
  父组件: 
  <CustomInput :value="name4" @input="name4=$event"/>
  子组件: 
  props: ['value']
  <input type="text" :value="value" @input="$emit('input',$event.target.value)">
  ```

- 利用v-model能做什么?

  - v-model不仅能实现原生标签的双向数据绑定, 也能实现组件标签的双向数据绑定实现父子组件间数据双向同步
  - 一般用于封装带表单项的复用性组件
  - elment-ui中: Input/CheckBox/Radio/Select等表单项组件都封装了v-model

#### 组件间通信高级3: 属性修饰符sync

**理解本质:**

- 绑定一个自定义事件监听, 用来接收子分组分发事件携带的最新数据来更新父组件的数据

  ```vue
  <child :money.sync="total"/>
  //等价于
  <Child :money="total" @update:money="total=$event"/>
  ```

**利用sync能做什么呢?**

- 实现父子组件间数据双向同步

- 常用于封装可复用组件(需要更新父组件数据)

  v-model一般用于带表单项标签的组件

  sync一般用于不带表单项标签的组件

- element-ui中: Dialog就利用sync来实现组件的隐藏

#### 组件间通信高级4: $attrs与$listeners

**理解**

- $attrs:  排除props声明，class，style的所有组件标签属性组成的对象

- $listeners: 级组件标签绑定的所有自定义事件监听的对象

- v-bind：的特别使用

  ```vue
  <!-- 绑定一个全是 attribute 的对象,同时绑定多个数据 -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>
  ```

- v-on：的特别使用

  ```vue
  <!-- 对象语法 (2.4.0+) ,同时绑定多个事件-->
  <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
  ```

**使用它们能做什么呢?**

- 在封装可复用组件时: HintButton

  从父组件中接收不定数量/名称的属性或事件监听

  在组件内部, 传递给它的子组件

- element-ui中: Input就使用了v-bind与$attrs来接收不定的属性传递给input

**扩展双击监听**

- @dblclick="add2"

  绑定是自定义事件监听, 而el-button内部并没处理(没有绑定对应的原生监听, 没有分发自定义事件) 双击时, 不会有响应

- @dblclick.native="add2"

  绑定的是原生的DOM事件监听, 最终是给组件的根标签<a>绑定的原生监听

  当双击a内部的<button>能响应, 因为事件有冒泡

#### 组件间通信高级5: $children与$parent属性

**理解**

- $children: 所有直接子组件对象的数组, 利用它可以更新多个子组件的数据（不确定顺序）
- $parent: 父组件对象, 从而可以更新父组件的数据
- $refs: 包含所有有ref属性的标签对象或组件对象的容器对象

**利用它们能做什么?**

- 能方便的得到子组件/后代组件/父组件/祖辈组件对象, 从而更新其data或调用其方法
- 官方建议不要大量使用, 优先使用props和event(太强大不好限制)
- 在一些UI组件库定义高复用组件时会使用$children和$parent, 如Carousel组件

**扩展：组件mixin技术_复用组件功能**

- 问题: 多个组件有部分相同的js代码 ?

- 什么时候使用: 当多个组件的JS配置部分有一些相同重复的代码时

- 本质: 实现Vue组件的JS代码复用, 简化编码的一种技术

- 使用方法

  ```js
  1. 创建mixin.js配置文件，并写入复用配置
  2. import 引入配置
  3. 在需要使用的组件中`mixins: [myMixin]`,声明覆盖当前配置
  ```

#### 组件间通信高级6: 作用域插槽slot-scope

**什么情况下使用作用域插槽?**

- 父组件需要向子组件传递标签结构内容
- 但决定父组件传递怎样标签结构的数据在子组件中

- 后备内容概念：默认值

**编码**

- 子组件

  ```vue
  <!-- slot的属性会自动传递给父组件 -->
  <slot :row="item" :$index="index">  </slot>
  ```

- 父组件

  ```vue
  <template slot-scope="{row, $index}">
    <span>{{$index+1}}</span> &nbsp;&nbsp;
    <span :style="{color: $index%2===1 ? 'blue' : 'green'}" >{{row.text}}   </span>
  </template>
  ```

- 作用域插槽

  子组件

  ```vue
  <slot :user="user"></slot>	// 用:给父组件传入数据
  ```
父组件
  
  ```vue
  <template v-slot:default="{user}">
    <p>lastName --- {{user.lastName}}</p>
  </template>
  ```
  
  

#### 组件间通信高级7: vuex

- vuex用来统一管理多个组件共享的状态数据

- 任意要进行通信的2个组件利用vuex就可以实现

  A组件触发action或mutation调用, 将数据保存到vuex的状态中

  B组件读取vuex中的state或getters数据, 得到最新保存的数据进行显示
  
- 面试题

  1. mutation负责同步修改状态数据的，能不能异步修改

     可以异步修改

     如果异步修改的话会导致Vuex的调试工具失效，无法检测异步修改数据

  2. 设计的时候为什么建议mutation同步修改状态数据，而新增action负责异步

     Vuex的作用是给多个组件共享数据

     如果支持mutation异步修改数据，又因为异步的特性，会导致store对象中state数据发生错乱甚至是报错

     为了数据的安全

  3. Vuex刷新页面，数据丢失问题

     方案一：Vuex的数据都是每次组件加载时候动态请求获取数据保存(性能差，因为网络问题可能有网络延迟)

     方案二：将Vuex中的数据每次同步更新保存到sessionStorage中( state中的数据是动态的，就需要一直要同步到sessionStorage中，性能差)

     方案三：在页面刷新之前获取Vuex的数据，将数据保存在sessionStorage中，页面加载后从sessionStorage中获取

     ```js
     // beforeunload 页面即将刷新之前调用
     window.addEventListener('beforeunload', () => {
       sessionStorage.setItem('test2', JSON.stringify(this.personArr))
     })
     // 读取sessionStorage中是否有之前缓存的数据
     let personArr = sessionStorage.getItem('test2')
     // 如果有： 更新Vuex中状态数据
     personArr && this.changePersonArrMutation(JSON.parse(personArr))
     ```

### computed和watch的区别

- **computed** 

  1. 支持缓存，只有依赖数据发生改变，才会重新进行计算

  2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化
  3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

  4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
  5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

- **watch**

  1. 不支持缓存，数据变，直接会触发相应的操作；
  2. watch支持异步；
  3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

  4. 当一个属性发生变化时，需要执行对应的操作；一对多；

  5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，

  　　immediate：组件加载立即触发回调函数执行，

  　　deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

### 如何理解vue的渐进式

在原有大系统的上面，把一两个组件改用它实现,只做了自己该做的事，没有做不该做的事，仅此而已。

### 自定义指令

```js
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
```

### vuex和redux的区别

- reducer（纯函数，根据 action 和旧的 store 计算出新的 store， mutation里面直接修改 state
- 状态更新提交接口：==dispatch==    状态更新提交接口：==commit==



### MVVM

- M --> Model 数据层（为模板页面提供数据 data）

-  V --> View 视图层（模板页面）

- VM --> ViewModel 通过数据绑定和DOM事件监听来实现 Model 和 View 的双向数据绑定

​       数据绑定： Model --> View

​       DOM事件监听: View --> Model

### Vue数据流

1. Vue也是一个单项数据流的框架
2. Vue通过指令实现了双向数据绑定： v-model
3. v-model都做了哪些事情; <input v-model='msg' />
   1. 将指定变量的数据赋值给input的value
   2. 给当前的表单相自动绑定一个input事件，监听View层表单项数据发生改变获取最新value的同时更新Model的数据

### 数据劫持-数据绑定

流程：new MVVM()

1. 数据代理 (_proxyData)

​       将data数据代理到vm上，并定义属性getter和setter

​       当调用getter时，内部实际上是读取原属性的值 vm._data[key]

​       当调用setter时，内部实际上是设置原属性的值 vm._data[key] = val;

2. 将data数据变成响应式数据 (observer)

​       递归遍历原data所有数据（不是vm上的数据/不是代理数据）重新定义属性的getter和setter

​       将其定义成响应式数据

​       同时每一个响应式属性都会有对应一个唯一的dep，这个dep通过闭包的方式保存在getter和setter中

​        getter

​         建立dep和watcher的联系

​         在dep中通过subs保存多个watcher

​         在watcher中通过depIds保存多个dep

​       setter

​        dep.notify() 通知当前dep中所有watcher去更新用户界面

3. 模板编译

​       1) 将el所有元素子节点添加到fragment文档碎片节点中

​       2) 编译fragment节点中模板语法

​          递归遍历fragment所有字节点

​          判断子节点元素类型 nodeType

​          如果是元素节点 nodeType === 1

​          获取元素所有属性，判断属性里面是否包含指令属性 v-

​          	 事件指令属性 on

​         	   node.addEventListener(eventType, cb.bind(vm), false)

​           	普通指令属性

​            	根据指令类型来执行不同的 updater 方法更新用户界面

​            	同时会创建一个watcher（此时会读取vm属性，最终会触发getter从而建立dep和watcher之间的联系）

​           	 解析完指令属性后，最终移除元素上的指令语法属性

​         如果是文本节点并且包含插值语法 nodeType === 3

​          	直接调用 textUpdater 更新用户界面

​          	同时会创建一个watcher（此时会读取vm属性，最终会触发getter从而建立dep和watcher之间的联系） 

​      3) 将编译好的fragment插入到el中生效

​     最后当用户更新data数据时， this.name = 'rose'

​     触发name的setter方法

​     调用dep.notify() 通知当前dep中所有watcher去更新用户界面

​     从而用户界面发生变化

​     总结：当数据更新时，即更新数据也更新用户界面。这样的数据就是响应式数据

### Vue实例的生命周期函数

1. 初始化渲染阶段（new Vue()产生，只会执行1次）

- **beforeCreate()**

  在实现数据代理和监听之前调用的

  所以：不能访问data/methods数据，不能创建vm之前触发的，此时已经创建了vm

- **面试题1**： 在beforeCreate中如何获取data中的数据值

  `this.$options.data().msg`

- **created()**

  在实现数据代理和监听之后调用的

  可以访问所有数据

- **beforeMount()**

  在页面挂载（渲染）之前触发

- **mounted()**

  在页面挂载（渲染）之后触发
  
  $el：element $el代表将虚拟DOM对象编译后的真实DOM对象片段,在mounted可见

2. 更新状态（当data数据发生变化，就会自动更新, 触发n次）

- **beforeUpdate()**

  在更新之前触发

  此时data数据已经更新完毕，但是页面没有更新

- **updated()**

  在更新之后触发

  data数据更新完毕，页面也更新完毕

3. 销毁/死亡阶段( this/vm.$destroy()触发，触发1次 )

   页面的动态数据在Vue组件**实例**销毁的一瞬间使用其最后的数据

   静态页面还在

- **beforeDestory()**

  在销毁之前调用

- **destoryed()**

  在销毁之后调用

#### 重要生命周期函数（开发中常用） 

- **created / mounted** 

  发送AJAX请求、设置定时器等一次性任务

  created速度更快

- **beforeDestroy** 

  做一些收尾工作：取消AJAX请求，清除定时器等

#### 周期函数补充

- 动态组件

  `<component :is="comName"></component>`  is属性来切换不同的组件

  正常传入props数据就可以接受到

- 缓存组件

  ```vue
  <keep-alive :include="['a','b']>
    <component :is="view"></component>
  </keep-alive>
  ```

- **errorCaptured(errObj, errVM, errMsg)**

  捕获一个来自子孙组件的错误时被调用

  return false // 阻止错误继续向上传播，并且不会在浏览器控制台抛出错误

  参数：错误对象，抛出错误的实例，错误信息

##### 在缓存组件的基础上存在的声明周期

- **activated()**

  每次缓存组件被激活时就会调用

- **deactivated()**

  缓存的组件停用时调用，可替代destroyed

### 为什么组件中的data必须是函数形式？

​	Vue解析组件标签时，会找到组件的构造函数，创建组件实例对象，根据实例对象的内容进行显示

​	有三个组件标签，就会创建三个组件实例对象，此时，如果data使用的是对象形式，那么创建组件实例对象，进行数据代理，三个组件实例对象代理的data数据是同一个对象。那么只要有一个变化，全都变（不OK）

​	每个组件应该要单独使用自己的数据。所以data要使用函数。

​     那么创建组件实例对象，进行数据代理，会调用data函数得到新data对象从而进行数据代理，每一个组件实例对象得到的是新的对象，互不影响

### 路由

- 当从 C 组件切换到 C 组件（只更新参数的时候），C 组件并不会被重新创建或卸载，而是复用之前 C 组件，这样会导致只有路由变化，页面没有发生变化

  <span style="color:red;">解决方案：</span>

  ​	使用watch进行监视，因为每次更新时，$route都会创建一个新对象 ，而不是原对象，所以所有数据都是新的，可以监视

  ```js
  watch: {
    $route(to, from) {
      // to 变化前的路由对象
      // from 变化后的路由对象
    }, 
  }
  ```

- **history模式刷新404问题解决方法**

  通过配置webpack来解决：在devServer中加 historyApiFallback: true

  index.html 需要将 href="./bootstrap.css" 改成 href="/bootstrap.css"

  webpack.config.js 需要output上增加 publicPath: '/'

- **命名路由的时候params和query分别可以和什么搭配使用**

  query + name

  query + path

  params + name
  
- **路由传参**

  1. query
     传参方式：

         1. 注册的路由的时候不需要做任何事情
            2. 请求的时候通过path?key=value&key2=value2

     获取:  $route.query.key

     使用场景：适合多个参数

  2. params

     传参方式:

     1. 注册路由的时候需要声明占位符，{path: '路由路径/:key(占位符)'}
     2. 请求的时候通过 path/params参数

     获取:  $route.params.key

     使用场景：

     1. 通常只有一个参数的时候
     2. 该参数通常是一个标识id

  3. meta

     传参方式:

     1. 注册的时候通过meta字段进行参数设置

     获取:  $route.meta.key

     使用场景：

     1. 路由元信息，用于描述当前的路由信息
     2. 可以自定义参数内容的时候(可以有多个)

  4. props

     传参方式:

     1. 布尔值(需要搭配params参数使用)
     2. 对象(用于自定义参数)
     3. 函数(自定义参数 + 路由信息)

     获取:  在组件内部通过props接收获取

     使用场景：用来解耦$route和组件实例的耦合度

- **params传入多个参数行不行**

  可以，第一次加载没问题，刷新没有用冒号指定的参数消失

  只有在路由中指定：的参数才可以正常使用

- **$router VS $route的区别**

  1. $router

     路由器对象

     用来控制路由的跳转，更多使用的是其的方法

  2. $route

     路由信息对象

     包含当前路由的所有信息(path, query, params, meta)

### 导航守卫（路由守卫）

#### 全局前置守卫

```js
router.beforeEach((to, from, next) => {
  // 使用场景： 验证用户身份，判断用户是否登录
  if(isLogin){ // 如果登录，正常跳转至home
    next()
  }else { // 如果未登录就跳转至登录界面
    if(to.path === '/login'){
      next()
    }else {
      next('/login')
    }
  }
})
```

#### 全局解析守卫

- 这和 `router.beforeEach` 类似，区别是在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后**，解析守卫就被调用。

```js
router.beforeResolve((to, from, next) => {
  // 负责解析路由地址，加载对应的路由组件
})
```

#### 全局后置钩子

```js
router.afterEach((to, from) => {
  // 路由完全跳转后执行
})
```

#### 组件内的守卫

```js
beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
    // 因为当守卫执行前，组件实例还没被创建
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
},
beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
},
beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
}
```

### 路由懒加载

引入路由时，动态引入，代码分割，异步加载，例：

```js
const Home = () => import('../components/Home/Home')
```

import函数不是webpack提供的语法。是es6语法

### Vue.use

1. 自定义Vue插件需要向外暴露对象或者是函数

2. 如果向外暴露对象的话，对象中必须有install方法

3. 如果向外暴露的是函数的话，那么该函数本身就是install方法

4. 当Vue.use()的时候，会自动调用install方法，并且将Vue对象作为实参传入到install方法中

### 打包相关

- 关闭map文件映射配置

  productionSourceMap: false, // 关闭map映射文件



## Vue 前台项目问题

-  v-for的优先级高于v-if: 先执行v-for的遍历, 每遍历一个再进行v-if的判断

### 路由跳转与传参相关问题

#### 面试相关

**面试问题1: 指定params参数时可不可以用path和params配置的组合?**

​	不可以用path和params配置的组合, 只能用name和params配置的组合

​	query配置可以与path或name进行组合使用

**面试问题2: 如何指定params参数可传可不传?**

​	`path: '/search/:keyword?'`

**面试问题3: 如果指定name与params配置, 但params中数据是一个"", 无法跳转**

​	解决1: 不指定params

​	解决2: 指定params参数值为undefined

**面试问题4: 路由组件能不能传递props数据?**

​	可以: 可以将query或且params参数映射成props传递给路由组件对象

```js
//在routes中配置
props: route=>({keyword1:route.params.keyword, keyword2: route.query.keyword })
```

**面试问题5(非常重要): 编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误**

​	面试问题: 在做项目时有没有遇到比较难的问题?(可做回答)

回答步骤：

1. **我的问题**: 我在上一个项目时没有问题, 后面再做一个新的项目时就有了问题

2. **原因分析**: vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个promise来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的promise

3. **解决办法**:解决1: 在跳转时指定成功或失败的回调函数, 通过catch处理错误

   ​				解决2: 修正Vue原型上的push和replace方法 (优秀)

   ```js
   // 缓存原型上的push方法
   const originPush = VueRouter.prototype.push
   VueRouter.prototype.push = function (location, onComplete, onAbort) {
     console.log('push()', location, onComplete, onAbort)
     // this是路由器对象 $router
     // 如果调用push, 传递了成功或者失败的回调函数
     if (onComplete || onAbort) {
       // 让原来的push方法进行处理
       originPush.call(this, location, onComplete, onAbort) // 不用返回, 因为执行的结果返回是undfined
     } else { // 如果调用push, 没传递了成功或者失败的回调函数, 可能会抛出失败的promise, 需要catch一下
       return originPush.call(this, location).catch(() => {
         console.log('catch error')
       })   // 必须返回产生的promise对象
     }
   }
   ```

### **解决在二层及以上的路由路径上刷新, 丢失reset样式的问题**

- 因为history模式的缘故

  页面中引入reset: `<link rel="stylesheet" href="./css/reset.css"> `

- 解决： 

  `<link rel="stylesheet" href="/css/reset.css">`

### 对axios进行二次封装（面试必说）

1. 配置通用的基础路径和超时: axios.create({baseURL, timeout})

2. 显示请求进度条

   ​	显示: 准备发请求前显示, 在请求拦截器中执行NProgress.start()

   ​	隐藏: 请求结束隐藏, 在响应拦截器成功/失败回调中NProgress.done()

3. 成功返回的数据不再是response, 而直接是响应体数据response.data

   ​	响应拦截器成功的回调中: return response.data

4. 统一处理请求错误, 具体请求也可以选择处理或不处理

   ​	在响应拦截器失败的回调中: alert提示错误信息, return Promise.reject(error)

### 测试调用接口请求函数（跨域问题）

1. 出404的错误

   ​	 axios请求配置的地址: /api/product/getBaseCategoryList'

   ​     当前发请求所在的地址:　http://localhost:8080/

   ​	最终ajax请求的地址: http://localhost:8080/api/product/getBaseCategoryList (没人处理)

2. 解决办法1

   ​	配置baseURL: http://182.92.128.115/api   ==> 成功的前提是后台允许ajax跨域

3. 使用代理服务器转发到目标接口地址 (使用代理解决ajax跨域)

   ​	配置baseURL: /api

   ​	配置代理: vue.config.js中

   ```js
   devServer: {
     proxy: {
       // 配置代理
       "/api": {
         // 只处理以/api开头的请求
         target: "http://182.92.128.115", // 转发的目标地址
         changeOrigin: true, // 支持跨域
       },
     },
   },
   ```

#### vuex的基本使用

- store对象: state, mutations, actions, getters配置store对象: 在vm中配置

#### vuex多模块编程

- 当vuex管理的数据个数很多时使用
- 好处: 每个功能模块的数据单独管理, 更方便, 更有扩展性

#### vuex多模块编程的总state结构

- 要根据具体分出的模块进行调用

```js
{
    user: {
        userInfo: {}
    },
    home: {
        baseCategoryList: []
    }
}
```

![image-20200505223553475](C:\Users\wzy\AppData\Roaming\Typora\typora-user-images\image-20200505223553475.png)

#### vuex与api交互

- 异步action: 调用api接口请求函数 ==> 成功之后commit ==> 调用mutation ==> 更新状态数据

### 利用lodash进行函数节流处理

**问题: mouseenter事件频繁触发会导致分类列表更新卡的现象**

- 解决: 使用lodash的throttle函数进行节流处理, 限制更新的次数

#### 优化减小打包文件: 对lodash库实现按需引入 

```js
import _ from 'lodash'  // 引入整体lodash  ==> 打包了没用的工具函数, 打包文件变大
import throttle from 'lodash/throttle'  // 只引入我需要的工具函数   打包文件减少1.4M
```

#### 解决快速移出后可能显示第一个分类的子分类列表的bug

    原因：在最后一个mouseenter事件延迟0.3m才执行更新的回调函数
        在这个0.3s之内可能已经移出去了
    解决: 给currentIndex设计了3个值:
            -2: 在整个大div外面
            -1: 进入了包含所有分类的大div上
            >=0: 在某个分类上
        在准备更新currentIndex之前, 需要判断currentIndex当前不能为-2

### 优化减少组件对象数量

 **使用编程式导航代替声明式导航**

    问题: 使用声明式导航跳转Search, 每个分类项都需要渲染一个RouterLink组件对象  ==> 显示缓慢
    解决: 使用编程式路由导航, 不用创建多个Routerlink组件对象 ===> 显示更快

### 优化事件处理效率

**利用事件委托**

    问题: 每个分类都绑定了点击监听, 监听回调函数的数量就会非常多  ==> 效率不太高
    解决: 使用事件委托, 从n个点击监听变为1个点击监听 ==> 效率高些
    问题: 需要在点击回调中得到相应的分类数据?  ===> 利用标签的data自定义属性

### 利用标签data自定义属性携带动态数据

    在标签中指定自定义属性: <a data-categoryName="abc" data-category1Id="3">
    在事件回调函数中读取自定义属性数据: const {categoryname, category1id} = event.target.dataset

### 优化请求执行的位置, 减少请求次数

    问题: 在首页与搜索页进行路由跳转时, 总会重新请求分类列表    没有必要, 只要一次就可以了
    原因: 首页和搜索页有各自的TypeNav标签对象, 跳转时都是重新创建的, 而我们是在mounted中发请求
    解决: 将dispatch发请求的代码放在App的mounted中执行

### Mock接口数据

    下载mockjs
    引入mockjs得到Mock
    mock接口: Mock.mock('/mock/xxx', {code: 200, data: banners/floors})
    mockAjax: 指定baseURL为/mock
    api/index.js: reqBanners = () => mockAjax('/banners')
    在组件中调用测试: reqBanners()

### 使用swiper

- 创建并配置swiper对象: 必须在列表显示显示之后创建 ===> 在mounted()中创建

#### 解决多个swiper效果冲突的问题

​	问题: 针对某个swiper界面创建一个swiper对象, 它会影响了其它界面的swiper界面

​	原因: new Swiper ('.swiper-container'), 类名选择器匹配了页面中所有的swiper界面, 都产生了效果

​	解决: 使用ref技术: 通过ref标识swiper的根div, new Swiper (this.$refs.swiper)

#### 解决swiper动态页面轮播的bug

​	问题: 异步动态获取数据 + 直接在mounted中创建Swiper对象 ===> 没有轮播效果

​	原因: swiper对象创建得太早

​	解决: 使swiper对象在列表数据显示之后创建

​			**办法1**: 使用延迟定时器延迟一定的时间才创建 ==> 不合适, 因为请求获取的时间是不定的

​			**办法2**: watch + $nextTick()

​					通过watch能知道banners有数据了(变化了)

​					通过 $nextTick(callback)知道界面也更新了，那我们就可以在callback中创建swiper对象

**理解nextTick()**

- nextTick()需要在数据更新之后界面更新前我们调用

- 指定的回调函数在这次数据更新导致的界面更新完成后立即执行

#### 解决Floor组件中轮播有问题的bug

问题: banners的轮播可以, 但2个Floor的轮播都没有效果

原因: (在v-for以后轮播组件已经有数据了，不是从空数组变为有数据，所以watch不调用)

​	 	基础理解: 给组件标签传入的属性值是空数组/undefined, 组件对象会创建，如果是通过v-for遍历一个空数组或undefined来产生多个标签, 组件对象不会创建

​		watch默认: 初始创建显示不会执行, 只有在数据变化后才会执行

解决:

​		**办法1**: mounted() + watch回调

​					mounted()中: 判断如果已经有数据了, 立即创建swiper对象

​					watch回调: 判断如果有数据, 延迟创建swiper对象

​		**办法2**: watch

​					给watch指定2个配置

​					handler: 判断如果有数据, 延迟创建swiper对象

​					immediate: 指定为true, 表示在初始显示之前就会调用一次

### 响应式数据对象

#### **添加新属性**

错误方式: 

​		直接添加: this.options.trademark = 'xxx'  ==> 不会自动更新界面

原因: 

​		vue内部没有对添加的属性进行劫持操作(没有对应的setter监视)

正确方式:

​		vm.$set( target, key, value )

​		Vue.set( target, key, value )

​		为响应式对象添加一个属性，确保新属性也是响应式的，并且能够触发视图更新

#### 删除属性

错误方式: 

​		直接添加: delete this.options.trademark  ==> 不会自动更新界面

原因: 

​		vue内部给响应式属性添加的setter, 只能监视属性值的改变, 不能监视属性的删除

正确方式:

​		vm.$delete( target, key )

​		Vue.delete( target, key )

​		删除属性, 同时更新界面

### 自定义分页组件: Pagination

**自定义通用型/复用型组件的基本步骤**

- 实现静态组件: 模板/样式写好

- 设计从外部接收的数据: props

- 设计内部包含的数据: data

- 设计基于props和data的计算属性数据: computed

- 根据props和data数据和computed进行动态显示

  **v-for的优先级高于v-if: 先执行v-for的遍历, 每遍历一个再进行v-if的判断 面试题**

- 更新数据, 更新界面

  用户操作组件界面元素时, 更新当前组件的data数据

  子组件更新data数据的同时, 可能需要通知父组件做一些更新父组件数据的操作(可能异步/同步)

  父组件更新data数据的同时, 可能也要去更新子组件的数据









## React基础

### 基础

- JSX语法最终都会经过babel编译，编译成JS语法
- 组件名首字母必须大写，JSX一旦标签首字母小写就会当做html元素解析，但是html中没有这个元素就会报错
- 内部返回虚拟DOM对象元素必须有结束符
- 必须要保证更新的数据是一个全新数据（不能push unshift等）
- Fragment  能作为多个虚拟DOM元素的根节点    优点：不会生成真实DOM元素   简写方式<></>

#### 通信方式

- props

  用PropTypes限制传入类型

- refs

  xxx = React.createRef()，再作用在标签上

- 消息订阅(subscribe)-发布(publish)机制

  import PubSub from 'pubsub-js' //引入

  PubSub.subscribe('delete', function(msg,data){ }); //订阅

  PubSub.publish('delete', data) //发布消息

- context  内部包含两个组件

  context.Provider 提供者（负责向后代组件提供数据）

  context.Consumer 消费者（负责消费数据，使用父（爷）组件提供的数据）

- forwardRef，获取工厂/纯函数组件的ref

  函数组件通过第二个参数接收ref

- render props

  本质上是一个组件，将B组件渲染到A组件内部，同时A组件传递必要的props（往往是属性数据，而不是方法）

  ```react
  <A render={(count) => {return <B count={count} />;}}/>
  ```

- 总结：

  触发事件元素和要收集数据元素是同一个元素，就e.target

  触发事件元素和要收集数据元素不是同一个元素，就用refs

#### 生命周期函数

**始化流程**

- constructor
- componentWillMount    将要挂载
- render     开始执行
- componentDidMount     挂在完成

**更新流程（三种方式触发）**

1. 父组件this.setState导致子组件重新渲染，子组件会触发：

   componentWillReceiveProps	将要接收数据

   shouldComponentUpdate	

   componentWillUpdate

   render

   componentDidUpdate	更新完成

2. 父组件this.setState, 父组件触发：

   shouldComponentUpdate

   componentWillUpdate

   render

   componentDidUpdate

3. 父组件this.forceUpdate, 父组件触发：

   componentWillUpdate

   render

   componentDidUpdate 

**卸载**

- componentWillUnmount 

  直接将之前插入到指定容器的DOM结构直接移除

  页面上没有该内容  

**即将废弃的生命周期**

- componentWillMount
- componentWillUpdate

**新的生命周期**

- static getDerivedStateFromProps(props, state){}

  用来取代willMount和willUpdate

  render 方法之前调用，并且在初始挂载及后续更新时都会被调用

  返回一个对象来更新 state，如果返回 null 则不更新任何内容

#### 重要生命周期函数

- componentDidMount

  发送请求、设置定时器、绑定事件等一次性任务

- shouldComponentUpdate    做性能优化

  返回值 true 要更新

  返回值 false 不更新

- componentWillUnmount

  取消请求、清除定时器、解绑事件等收尾工作

#### 高阶组件：HOC

- 本质上是一个函数：执行函数接受一个组件作为参数，返回值是一个新组件
- 给高阶组件命名 --> displayName优先级最高
- 可用高阶函数的形式传参
- 可用装饰器语法调用

#### Hooks（钩子）

- 本质就是函数，能让你使用React组件的状态和生命周期函数...

- 作用：让代码更加可复用，不用在定义繁杂的HOC

- 使用：

  - 让工厂函数组件拥有状态数据state

    `const [状态数据（初始化为defaultValue）, 更新状态数据的方法] = React.useState(defaultValue)`

  - 让工厂函数组件拥有生命周期函数（componentDidMount componentDidUpdate componentWillUnmount）

    ```react
    React.useEffect(() => {
        return () => {
          PubSub.unsubscribe("MSG");
        };
    },[])
    ```

#### react-router

- **Hash 模式** 

  兼容性好

  缺点带#

  刷新页面时只会把#前面地址发请求

- **History 模式**

  兼容性稍差

  地址很干净

  刷新页面时会把所有地址带上发请求（导致开发时刷新浏览器404问题）

  解决方法：

  ​		出现404，就直接返回 index.html

  ​		webpack配置devServer historyApiFallback: true

  问题：引入资源（css/js）路径问题

  ​		webpack配置output publicPath: "/"

  ​		index.html --> "/bootstrap.css"

- **API**

  ```react
  import {
    BrowserRouter,HashRouter,Link,NavLink,Route,Redirect,Switch,
  } from "react-router-dom";
  ```

- **路由组件三大属性（都在props上）**

  location     pathname 当前路由地址    state 

  history       push/replace/goBack/goForward/listen 等方法，用来操作浏览历史记录

  match        params 参数
  
- **特点**

  1. 默认是模糊匹配，如果想要精准匹配，需要给Route标签添加一个属性 exact
  2. 默认每次匹配都会匹配所有注册路由
  3. 性能优化相关： Switch, 一旦有匹配成的路由就停止匹配

- **路由传参**

  1. params传参

     ```react
     <Route path='/home/:id' component={Home}></Route>
     ```

  2. props 传参

     ```react
     <Route path='/personal' render={() => <Personal num={123}/>}></Route>
     ```

     

### 面试

#### 工厂函数组件和ES6类组件的区别

1. this不一样

   工厂函数没有this，ES6类组件函数中有this

2. 功能不一样

   工厂函数没有this，有些功能默认实现不了；ES6类组件有this，所以可以实现 

- 总结

  工厂函数组件一般用来定义功能简单组件

  ES6类组件一般用来定义功能复杂组件

#### 函数柯里化

- 是闭包的典型应用

```react
// 普通函数
function fn(a, b) { return a + b}
// 经过函数柯里化处理的函数
function fn(a) {
  return function (b) {
    return a + b;
  }
}
```

#### 性能优化

- 减少render调用次数，从而减少diff比较和重新渲染次数

1. 自己编写shouldComponentUpdate（nextProps, nextState）函数进行优化

2. PureComponent：组件内部实现了一种类似shouldComponentUpdate的比较

   ```react
   import { PureComponent } from "react";
   export default class Index extends PureComponent {}
   ```

- shouldComponentUpdate 和 PureComponent 同时存在只会生效 shouldComponentUpdate

#### Portals

- Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
- 通常情况下不会使用，一般用于Modal组件 
- 防止组件卸载/重新创建过程中创建多个div

#### 如何遍历显示子路由

- 没有通过Route加载，所以没有路由组件三大属性

- 解决：react-router-dom有一个高阶组件withRouter，withRouter内部保存路由组件的三大属性，会给被包装组件传递三大属性

- 判断routes中哪个配置匹配上当前路径

  forEach 一般写代码推荐forEach，语义化更好，一般用于要全部遍历的场景

  for循环 一般写库或框架，追求极致性能使用。性能好，一般用于遍历可中断的场景

- 判断 当前路径是否以一级菜单开头：

  String.prototype.startsWith()

  正则表达式

注意：

​		如果Route组件不加exact属性（严格模式），则会默认匹配以该路径开头的组件

#### 虚拟DOM的diff算法

**diff 策略**

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

- 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。

**tree diff**

- 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。

- 即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

- 如果出现了 DOM 节点跨层级的移动操作，性能不好!

**component diff** 

- 如果是同一类型的组件，按照原策略继续tree diff。

* 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。

* 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。

**element diff**

- 允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！

- 通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动

- 在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

### 深入理解setState

- **setState()更新状态的两种写法:**

  setState(stateChange,[callback])--------对象式的setState

  setState(updater,[callback])---------函数式的setState

- **setState()更新状态的动作是同步还是异步的**？（setState()执行的位置对其后续动作的影响）

  在由react所控制的回调函数中更新的动作是【异步】的，如：生命周期钩子 / react所监听的事件

  在非react控制的异步回调函数中更新的动作是【同步】的，如：定时器的回调 / 原生事件监听回调 /Promise所指定的成功、失败回调 / ajax所指定的成功或失败的回调

- **关于异步的setState()连续多次调用的问题**

  1. 多次调用，如何处理？

     若是对象式的setState，多次更新状态的动作合并为一次(只以最后一次为准),所以就调用一次render

     若是函数式的setState，每次更新的动作都会生效(更新的动作不合并)，但是只会调用一次render

  2. 注意：

     若函数式setState和对象式setState混用的时候，要把函数式写在最后

  3. 如何得到异步更新后的状态？

     在setState第二个参数的回调里

## 移动端

- 1英寸(inch) = 2.54厘米(cm)

-  IPhone 6 的屏幕分辨率为 750 * 1334  设备独立像素为 375 * 667

- 物理像素：由屏幕制造商决定，屏幕生产后无法修改

- css像素：单位是px，它是为 Web 开发者创造的

- 设备独立像素的出现，使得即使在【**高清屏**】下，也可以让元素有正常的尺寸，让代码不受到设备的影响，它是设备厂商根据屏幕特性设置的，无法更改。

- 1个位图像素对应1个物理像素，图片才能得到完美清晰的展示

- pc端视口：默认宽度和浏览器窗口的宽度一致，也被称为初始包含块`document.documentElement.clientWidth`

- 移动端视口:

  - 布局视口：一般是**<span style='color:red'>980px</span>**左右，布局视口经过压缩后，横向的宽度用css像素表达就不再是375px了，而是980px

  - 视觉视口：用户可见的区域，它的绝对宽度永远和设备屏幕一样宽

  - 理想视口：布局视口宽度 与 屏幕等宽（设备独立像素），靠meta标签实现

    ```html
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    ```

### 适配

#### 1.viewport 适配

- 方法：拿到设计稿之后，设置布局视口宽度为设计稿宽度，然后直接按照设计稿给宽高进行布局即可。
- 一般适用于：计图稿宽度 < 375

#### <span style="color:#ee0b41">2.rem适配</span>

- 方案一：（百度）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小 = **( 当前设备横向独立像素值 *100) / 设计稿宽度**</span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / 100** </span>
  4. 增加 JS 代码进行实时适配
- 方法二：（淘宝、搜狐、唯品会）
  1. 设置完美视口
  2. <span style="color:#ee0b41">通过js设置根字体大小  = **当前设备横向独立像素值 / 10** </span>
  3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / (设计稿宽度 / 10)**</span>
  4. 增加 JS 代码进行实时适配

#### 3.vw适配

vw和vh是两个相对单位

- 1vw = 等于布局视口宽度的1%
- 1vh = 等于布局视口高度的1%

#### 4.1px物理像素边框

高清屏幕下 1px 对应更多的物理像素，所以 1 像素边框看起来比较粗，解决方法如下

##### 方法一

使用媒查询：

```css
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo{
        border: 0.5px solid black;
    }
}
或
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo2::after{
        transform:scaleY(0.5);
    }
}
```

##### 方法二

根据dpr扩大布局视口，例如dpr为n则布局视口改为原来的n倍，则元素尺寸均变为原来的n分之一，为了保证元素尺寸比例不变，扩大根字体为原来的n倍，但整个过程中边框一直用px作为单位，不用rem。

1. rem 页面布局

2. 元素的边框设置为 1px

3. 通过 viewport 中的 initial-scale 将布局视口扩大n倍，这样页面元素就比原来缩小了n倍

```js
var viewport = document.querySelector('meta[name=viewport]')
var scale = 1 / window.devicePixelRatio
viewport.setAttribute('content', 'width=device-width,initial-scale=' + scale);
```

4. 重新设置根元素字体

```js
var fontSize = parseInt(document.documentElement.style.fontSize);
document.documentElement.style.fontSize = fontSize * window.devicePixelRatio + 'px'
```

### 移动端事件

* touchstart   元素上触摸开始时触发
* touchmove   元素上触摸移动时触发
* touchend   手指从元素上离开时触发
* touchcancel   触摸被打断时触发

### 移动端中touchstart,touchend,click执行顺序

- touchstart
- touchend
- click，浏览器在 click 后会等待约300ms去判断用户是否有双击行为，如果300ms内没有再一次click，那么就判定这是一次单击行为

### 点击穿透

- touch 事件结束后会默认触发元素的 click 事件

  方法一：阻止默认行为

  方法二：使背后元素不具备click特性，用touchXxxx代替click

  方法三：让背后的元素暂时失去click事件，300毫秒左右再复原，属性`pointer-events: none;`

  方法四：让隐藏的元素延迟300毫秒左右再隐藏

### getComputedStyle

- 可读取到非内联样式上的属性
- 可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式

## 小程序

### 1. 小程序特点

1. 体积小，压缩包的体积不能大于2M
2. 没有DOM对象
3. 基于组件化开发
4. 小程序环境不同于浏览器环境
   1. 浏览器环境中全局对象： window
   2. 小程序环境中全局对象：wx
   3. 小程序环境中没有window对象

### 2. 小程序适配

1. 小程序适配单位： rpx(responsive px) 响应式单位
2. 小程序中规定所有的机型中页面宽度都是750rpx
3. iphone6: 1物理像素 = 0.5px = 1rpx ---> 1px = 2rpx
4. 小程序底层已经做了viewport适配

### 3. 小程序相关语法

1. 数据绑定

   1. 单项数据流: Model ---> view
   2. 修改状态数据： this.setData() 同步行为
   3. 页面中的数据均来自于data中，使用data中的数据的时候记住使用表达式{{}}
   
2. 事件绑定

   1. 事件分类： 冒泡事件 || 非冒泡事件
   2. 绑定的方式： bind + 事件名  || catch + 事件名
   
3. 路由跳转

   1. wx.navigateTo() || wx.redirectTo()
   
4. 本地存储
   1. 语法： 
      1. wx.setStorage() || wx.setStorageSync()
      2. wx.getStorage() || wx.getStorageSync()
   2. 注意点
      1. 单个key上限是1M
      2. 整体上限是10M
   
5. 全局传参

   app.js中可定义全局参数globalData

### 4. 向事件对象传参

1. 语法
   1. id=value
   2. data-key=value
2. 获取
   1. id: event.target.id || event.currentTarget.id
   2. data-key: event.target.dataset.key || event.currentTarget.dataset.key
3. 使用场景
   1. id：通常需要向event对象传递单一且唯一的标识
   2. data-key:   需要向event对象传递多个标识数据

### 小程序获取用户唯一标识（openId）

1. 客户端先通过wx.login(获取code
2. wx.request()发送code给服务器
3. 服务器端发送请求携带参数(code, appSecret（开发密钥）, appId)给微信服务器获取openId
4. 微信返回openId给服务器后，服务器进行加密再返回给前端
5. 前端进行本地储存，下次发送请求时携带参数

### 小程序支付流程

1. 用户在小程序客服端下单(包含用户及商品信息)
2. 小程序客户端发送下单支付请求给商家服务器
3. 商家服务器同微信服务器对接获取唯一标识openID
4. 商家服务器根据openId生成商户订单(包含商户信息)
5. 商家服务器发送请求调用统一下单API获取预支付订单信息
6. 商家对预支付信息签名加密后返回给小程序客户端
7. 用户确认支付（鉴权调起支付）
8. 微信服务器返回支付结果给小程序客户端
9. 微信服务器推送支付结果给商家服务器端


### 面试问题

- Iphone6的dpr为多少？Iphone6Plus比Iphone6显示图像清晰吗？

  视网膜屏幕是分辨率超过人眼识别极限的高分辨率屏幕，Iphone4的dpr = 2; 人类肉眼分辨的极限
  
- 生命周期函数实际测试和官网描述有差

- wx.setStorage()，单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB

- 性能优化

  一个页面一次只有一个video标签，其余的使用image代替
  
- 请求相关

  小程序为了安全起见只支持Https请求

  wx.request最大并发限制10个

- 如何使用组件

  先创建组件，在对应的json文件下设置component: true

  到使用组件页面的json文件中，注册组件填写相应的路径

- 使用npm包

  下载后，勾选使用npm模块，再构建npm，会将node_modules中的包打包到miniprogram_npm中

- 分包相关

  分包后可解决2M限制，并且能分包加载内容，提高性能

  分包后单个包的体积不能大于2M，所有包的体积不能大于16M

  1. 常规分包

     加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容

     分包的页面可以访问主包的文件，数据，图片等资源

  2. 独立分包

     独立分包可单独访问分包的内容，不需要下载主包

     独立分包不能依赖主包或者其他包的内容

     通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页 || 活动页

  3. 分包预下载

     在加载当前包的时候可以设置预下载其他的包

     缩短用户等待时间，提高用户体验

### 开发相关

- setData行为始终是同步的
- H5中实现滑块功能，推荐大家使用：better-scroll

#### 封装

- 封装函数：

  1. 功能点明确

  2. 函数内部保留静态的数据

  3. 将动态的数据抽取出来作为形参，由使用者根据场景不同动态传入实参

- 封装组件：

  1. 功能点明确 || 呈现效果

  2. UI组件 || js组件

  3. 组件内部保留静态的数据

  4. 将动态的数据抽取出来作为 props属性，由使用者根据场景不同动态以标签属性的形式导入

  5. 封装良好的组件应该规定传入props数据的必要性还有数据类型 propsType

## express

### 1. 基本使用

```js
// 引入
let express = require('express');
// 1. 生成应用实例
const app = new express(); // app: application 代表整个应用

// 3. 注册路由
app.get('/', (request, respone) => {
  console.log('1111');
  // 返回数据
  respone.end('success data');
});

app.get('/login', (req, res) =>  {
  console.log('2222');
  res.end('login data');
});

app.post('/register', (req, res) =>  {
  console.log('4444');
  res.end('register data');
});

// 2. 绑定监听(设置当前项目的端口号)
app.listen('3001', (err) => {
  if(err){
    console.log('服务器启动失败');
    console.log(err);
  }else {
    console.log('服务器启动成功');
    console.log('服务器地址： http://localhost:3001');
  }
})

```

### 2. 路由

1. 路由分类
   1. 前端路由
   2. 后端路由
2. 前端路由
   1. 发请求不需要走网络传输层
   2. 需要由前端指定的js库解析(vue-router, react-router-dom)
   3. 应用： SPA（single page application）
3. 后端路由
   1. 发请求需要走网络传输层
   2. 需要由服务器端解析
   3. 应用： 前后端交互

### 3. 路由参数

1. get请求
   1. params参数： 
      1. 请求： url/:id ==> url/参数
      2. 获取： req.params
   2. query参数:
      1. 请求：url?key=value&key2=value2
      2. 获取: req.query
   3. 总结:
      1. params参数只能有一个参数，适用于参数为标识数据
      2. query参数可以有多个
2. post请求
   1. params参数
   2. query参数
   3. body参数
      1. 相对安全
      2. 获取req.body，但是不能直接获取，需要使用中间键

### 4. res常用方法

1. res.end() 返回响应: 直接返回数据
2. res.send() 根据数据类型不同，自动做出判断处理，再返回，如：中文的话会自动设置content-type
3. res.set() 设置响应头的方法
4. res.json() 返回的数据一定是json数据，直接返回
5. res.cookie() 设置cookie
6. res.status() 设置状态码
7. res.redirect() 返回的是新地址，状态码通常是302，浏览器接收到响应以后会跳转至新的地址
8. res.download()  返回的文件信息，浏览器会自动下载该文件

### 5. 中间件

1. 本质
   1. 就是一个函数
2. 作用
   1. 处理请求，返回响应数据
   2. 获取，修改请求的参数及响应数据
   3. 执行下一个中间键
3. 体现形式
   1. (req, res, next) => {}
   2. req: 请求对象
   3. res: 响应对象
   4. next：是一个方法，用来调用下一个中间键
4. 注意
   1. 连续使用多个中间键的时候返回数据的动作应该放在最后且只有一次
   2. 路由对应的回调 也是中间键函数
   3. 如果请求方法和中间键共存的情况下，只能匹配一个，谁在前就匹配谁（满足匹配条件情况下）
























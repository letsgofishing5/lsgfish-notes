### 查看npm全局安装

```bash
npm root -g
```

全局安装后 ，可以使用他的cmd命令

```bash
npm i eslint -g
#执行eslint命令
eslint -h
eslint -v
```

### 使用Eslint

1. 创建项目

   ```bash
   npm init -y
   ```

2. 本地安装

   ```bash
   npm i eslint -D
   ```

3. 设置`package.json`文件

   ```json
   "script":{
       "lint":"eslint src",
       "lint:create":"eslint --init",
       "lint:f": "eslint src --fix"
   }
   ```

   1. `eslint src`：校验代码的程序，自动校验`src`目录下的所有 `.js` 文件
   2. `eslint --init：`生产`.eslintrc.js`文件，提供编码规则
   3. `eslint src --fix：`代码格式格式错误自动修复

###  使用husky配置Eslint进行语法强规则

必须要在仓库初始化完成之后再去安装husky（帮助 git 仓库生成钩子）

npm中搜 husky，按照官网来操作

```js
"husky":{
    "pre-commit":"npm run 脚本名称"
}
```

### 作用域 

Javascript中，只有**全局作用域**和**函数作用域**，而this的指向从来都是跟函数的调用位置调用形式有关

```js
普通调用(fun()) : window
隐式调用(obj.fun()) : obj
显示调用(fun.call(obj)) : obj
构造调用(new fun()) : 构造出来的实例对象
```

隐式丢失

​	当使用隐式绑定的形式去进行变量的赋值时(函数的传参)容易出现隐式丢失 

如何解决隐式丢失？

​	使用显示调用 或 硬绑函数 `bind` 来定死 `this` 指向

### 异步编程

JavaScript中，异步编程一定要等到同步编程结束后才能执行

```js
setInterval(()=>{
    console.log("异步任务执行了")
},1000)
for(let i = 0;i<10000;i++)
    {
        console.log("i:",i)
    }
//一秒钟后，异步任务执行了还是没有打印出来
```

### 闭包

变量的查找：左右查询 

1. 左查询：对等号左边的变量发起查询，如果整条作用域链上没有对应的变量声明，则会报错
2. 右查询：对等号非左边的变量发起查询，如果整条作用域链上没有对应的变量声明，则在全局自动声明一份（严格模式下报错）

#### 闭包条件

1. 内部函数引用外部变量

### promise

`promise` 是异步编程

```js
var promise = new Promise((resolve,reject)=>{
    console.log(resolve,reject)
    resolve("传递给promise实例的值")
})
```

promise 实例有三个状态

1. pending（默认情况下的状态）
2. fulfilled（resolve被调用）
3. rejected（reject被调用，或者出现异常）

### ES6模块化

```js
//不使用 default
export 代码块
export {
	代码块的名称,
	代码块的名称
}
import {代码块名称,代码块名称} from url
import {代码块名称 as 别名} from url
import * as 别名 from url
```

使用default

```js
export default {对象}
import 别名 from url
```

`default`模式可以写对象，而非`default`模式则不可以写对象，仅仅只是代码块

##### commonJS导入导出

```js
//test.js
module.exports = {}
exports.a="a"
```

```js
const test  = require('./test.js')
```

##### webpack @3.10.0

```bash
npm i webpack@3.10.0
npx webpack 打包文件 输出文件
```

